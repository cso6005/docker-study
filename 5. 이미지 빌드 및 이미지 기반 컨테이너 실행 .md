
# 이미지 생성 방법

실제로 컨테이너를 실행할 수 있도록 이미지를 생성하고 가져오는 두 가지 방법이 있다.

## **1. 이미 존재하는 이미지를 가져와서 사용**

*** 대표적으로 docker hub 에서 공식 이미지를 찾을 수 있음.* 

### **방법**

1. docker engine 를 켜고 cmd에서 아래 명령어를 입력한다.

```bash
docker run node
```

공식 노드 이미지로 이를 기반으로 하는 컨테이너를 생성할 수 있다.

이미지에는 환경 설정 코드가 포함되며 노드 설치가 포함되어 있다.

이 이미지를 실행시켜 애플리케이션을 실행할 경우, 노드 인터렉티브 쉘(NodeJS는 인터렉티브 모드를 제공하는데 기본적인 노드 명령어인 REPL을 사용할 수 있음)을 간단히 실행할 수 있다.

**⇒ 이미지는 컨테이너에 필요한 모든 코드와 코드를 위한 모든 도구를 보관하는데 사용되며,**

**run 명령을 사용하여 이미지의 인스턴스을 만드는 것이다.**

**즉, 해당 명령으로 이미지를 기반으로 하는 구체적인 컨테이너를 생성한다.**

**하지만, 기본적으로 컨테이너는 주변 환경과 격리되어 있으며 컨테이너 내부에서 실행 중인 인터렉티브 쉘이 있다고 해서 이 쉘이 사용자에게 노출되는 것은 아니다.**

- 도커의 모든 프로세스 표시하는 명령어
    
    ps : 프로세스를 나타냄. 
    
    -a 프래그 : 도커가 생성한 모든 컨테이너, 모든 프로세스 표시
    

```jsx
docker ps -a
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/406ba3d2-07c6-4d92-8f2e-455168240f35/17e10859-d0c5-4684-8506-1b009ae4fae8/Untitled.png)

무언가가 발생했지만 더 이상 실행되지 않았는데 컨테이너가 격리되어 실행되었기 때문이다.

노드를 이미지로 실행하거나 노드 이미지를 기반으로 하는 컨테이너로 실행했지만 이것으로는 안된다.

노드에 의해 노출된 인터렉티브 쉘은 **컨테이너에 의해 자동으로 우리에게 노출되지 않기 때문**이다.

- **it 플래그 추가 : 실제로 기본 노드 명령을 실행할 수 있는 인터렉티브 노드 터미널로 접속**
    
    아래와 같이 **-it 플래그를 추가함으로써**
    
    **도커에게 컨테이너 내부에서 호스팅 머신으로 대화형 세션을 노출**하고 싶다고 알릴 수 있다.
    

```jsx
docker run -it node
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/406ba3d2-07c6-4d92-8f2e-455168240f35/33ef1816-4cb6-4fb3-935c-21d1e94fbd12/Untitled.png)

**⇒ 여기서의 핵심은** 

**노드가 생성된 컨테이너 내부에서 실행 중이며, 이 추가 플래그를 추가함으로써**

**터미널로 들어가 그 컨테이너 및 컨테이너에서 실행 중인 노드와 상호 작용할 수 있게 되는 것이다.**

** 이러한 노드는 우리의 컴퓨터에서 돌아가는 것이 아닌데, 이를 증명해보자.

컨테이너를 종료하고, cmd에서 node -v 로 node 버전을 확인하려고 했을 때 node가 없다라는 에러가 날 것이다. 당연히 우리의 컴퓨터에 node가 깔린게 아니라 컨테이너 내부에 깔린 것이기 때문이다.

- **동일한 이미지를 기반으로 만들어진 여러 컨테이너가 동시에 실행 가능**

현재 우리는 실습을 통해 총 세번의 docker run 명령을 반복했다.

docker ps -a 명령을 하면, 동일한 이미지를 기반으로 하는 컨테이너가 세 개있는 것을 볼 수 있다.

docker run 명령의 반복에 의해 동일한 이미지를 기반으로 하는 여러 컨테이너가 구축되었음을 알 수 있고, 또, 이를 통해 **동일한 이미지를 기반으로 만들어진 여러 컨테이너가 동시에 실행 될 수 있음**을 알 수 있다.

## **2. Custom Image 사용**

일반적으로 공식 베이스 이미지를 받아 그 위에 코드 등을 추가하여, 자신만의 custom 이미지를 구축한다.

** vsc 사용 시, Docker 플러그인을 깔면, Docker 사용이 편함.

### 1. 이미지를 생성하기 위한 Dockerfile 명령어

```docker
FROM node

WORKDIR /app

COPY . /app

RUN npm install

EXPOSE 80

CMD ["node", "server.js"]
```

자체 이미지를 빌드할 때 실행하려는 도커에 대한 명령이 포함된다. 

- **기억할 점**

해당 Dockerfile 명령어는 컨테이너를 생성하는 명령이 아닌, 이미지를 생성하기 위한 명령어임을 기억해야 한다. 

해당 명령어를 통해 우리는 이미지를 생성 빌드하는 것이다.

그리고 만들어진 이미지를 통해 docker run 명령어로 컨테이너를 실행하는 것이다.

1. **일반적으로 FROM 명령으로 시작한다.**
    
    시스템에 존재하는 이미지 이름이나 도커 허브 상의 이미지 이름을 입력한다.
    
    이를 통해 다른 베이스 이미지에 자신만의 이미지를 구축할 수 있게 된다.
    
    - 만약, 도커 허브 이미지를 기반으로 컨테이너를 실행한 적이 있다면, **최초 실행에서 해당 이미지가 로컬로 다운로드 및 캐시**되었기 때문에 이미 로컬 머신에 존재하게 된다. 그래서 이 경우 로컬 도커 허브 이미지로 실행될 것이다.
        
        가장 중요한 것은 이게 인식될 것이라는 것이다. docker 는 node 라는 이름으로 해당 이름의 이미지를 찾을 수 있는 것이다.
        
    
2. **COPY** 

도커에게 로컬 머신에 있는 파일이 이미지에 들어가야 하는지 알려준다.

```docker
COPY . /APP
```

기본적으로 여기에서 두 개의 경로를 지정한다.

- 첫 번째 경로는 컨테이너의 외부, 이미지의 외부 경로이며, **이미지로 복사 되어야 할 파일들이 있는 곳**.
    
    이때, 컨테이너, 이미지는 환경과 코드를 갖고 있으며, 거기에서 실행됨을 기억해야 한다.
    
    그럼 해당 경로에서 Dockerfile 을 제외한 파일들이 복사되는 것.
    

- 두 번째 경로는  그 파일을 저장해야 하는 이미지 내부의 경로이다.
    
    모든 이미지와 이미지를 기반으로 생성된 모든 컨테이너에는 로컬 머신의 파일 시스템에서 완전히 분리된 자체 내부 파일 시스템이 있다. 이는 도커 컨테이너 내부에 숨겨져 있다.
    
    이때, 현 루트 디렉토리, 즉, 도커 컨테이너의 루트 엔트리를 사용하지 않고 서브 폴더를 사용하는 것이 좋다. 여기에선 /app 으로 설정 (해당 폴더가 존재하지 않으면 생성된다.)
    

⇒ Dockerfile과 동일한 폴더에 있는 모든 파일과 거기에 있는 모든 하위 폴더가 컨테이너 내부의 app폴더에 복사된다. 

1. **노드 애플리케이션의 종속성을 설치**

```docker
RUN npm install
```

**주의점**

이때, 디폴트로 이러한 모든 명령어는 도커 컨테이너 및 이미지의 작업 디렉토리에서 실행된다. 

디폴트로 그 작업 디렉토리는 컨테이너 파일 시스템의 루트 폴더이다. 

여기에서는 코드를 app 폴더에 복사하고 있기에 app 폴더 내에서 npm install 를 실행해야 한다.

그래서 모든 것을 복사하기 전에 아래와 같이 명령을 설정해야 한다.

1. **도커 컨테이너의 작업 디렉토리 설정**

```docker
WORKDIR /app
COPY . /app
RUN npm install
```

도커 컨테이너의 작업 디렉토리를 설정하는 명령이다. 이것으로 도커에게 해당 명령의 다음 명령부터는 그 폴더 내부에서 실행될 것임을 알리는 것이다. 

- **작업 디렉토리 상대 경로 ./**

**./ 는 도커 컨테이너의 현재 작업 디렉토리를 의미**한다.

컨테이너 내부 파일 시스템 내에서 ./는 상대 경로로 /app 을 나타내는 것.

당연히 /app 절대경로로 설정해도 된다. 강의에서는 절대 경로를 더 선호한다고 함. 파일 추측이 쉬움.

작업 디렉토리를 변경했기에 run 뿐만 아니라 COPY도 이 작업 디렉토리를 기준으로 실행된다.

즉, 이제 컨테이너 내부 파일 시

1. **서버 시작**

```docker
CMD [""]
```

배열을 사용하여, 명령을 두 개의 문자열로 분할해야 한다.

- **RUN 이 아닌 CMD 명령**

우리는 RUN 명령어를 입력하는 실수를 할 수 있다.

**이미지는 컨테이너의 템플릿이며, 이미지를 실행하는 것이 아니라, 이미지를 기반으로 컨테이너를 실행한다는 것을 기억해야 한다.**

우리는 컨테이너가 실행된 후에 노드 서버를 실행하고자 하는 것을 원하지, 해당 이미지 템플릿에서 서비를 실행시키는 것을 원하지 않는다.

RUN 명령어는 이미지와 템플릿에서 서버를 시작하려고 시도한다. 

RUN 과의 차이는 **이미지가 생성될 때 실행되지 않고, 이미지를 기반으로 컨테이너가 시작될 때 실행된다**는 것이다. 

즉, 도커에게 이미지를 기반으로 컨테이너가 생성될 때 마다 그 컨테이너 내부에 있는 node 명령을 사용하여 파일을 실행하도록 지시하게 되는 것이다.

** CMD에 특정하지 않으면 베이스 이미지가 실행되며, 그게 없는 경우 에러가 발

1. **포트 노출할 것을 문서화**

해당 노드 웹 서버의 경우, 포트 80에서 수신 대기하게 된다.

이때, 도커 컨테이너는 우리의 로컬 환경과 격리되어 있다.

컨테이너 내부의 노드 애플리케이션에서 포트 80을 수신할 때 컨테이너는 그 포트를 우리의 로컬 머신에 노출하진 않는다.

따라서 컨테이너 내부에서만 무언가를 수신 대기 중이기 때문에 해당 포트에서 수신할 수 없는 것.

```docker
EXPOSE 80
```

그렇기에 언젠 Dockerfile의 마지막 명령 전에 이 컨테이너가 시작될 때

**우리의 로컬 시스템에 특정 포트를 노출하고 싶다는 것**을 **도커에 알리는 EXPOSE 명령**을 추가해야 한다.

이때, 아래에도 설명이 나오지만,

EXPOSE  명령은 선택 사항이다.

이는 컨테이너의 프로세스가 이 포트를 노출할 것임을 문서화 할 뿐이지 실제로 포트를 노출하는 것이 아니다. docker run 을 실행할 때 -p 를 사용하여 실제로 포트를 노출하는 것이다. 

하지만 Dockerfile 에 EXPOSE 를 추가하여 해당 동작을 문서화하는 것이 모범적인 사용법이다.

### 2. Dockerfile 을 이미지로 변환

1. **이미지 빌드**

Dockerfile 에 작성된 명령을 기반으로 새 커스텀 이미지를 빌드하도록 도커에게 지시

이미지 실행이 아닌, 이미지를 만드는 명령

이때, Dockerfile을 찾을 수 있는 곳을 도커에게 알려줘야 한다.

‘.’ 으로 도커에게 이 명령을 실행하는 곳과 동일한 폴더에 Dockerfile 이 존재함을 알린다.

```bash
docker build .
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/406ba3d2-07c6-4d92-8f2e-455168240f35/165964a6-6b62-431c-bbdb-ff1c0fe1d5de/Untitled.png)

- 결과에서 이미지의 ID를 찾을 수 있다.

### 3. 이미지를 기반으로 컨테이너 실행

- 이미지 id를 통해 컨테이너 실행

```bash
docker run 해당 이미지 ID
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/406ba3d2-07c6-4d92-8f2e-455168240f35/7d87951d-753e-4b76-874f-b7a33d81ad70/Untitled.png)

컨테이너는 시작되며, 완료되지 않고 계속 실행된다. 그 이유는 여기서 실행한 명령  `CMD [”node”, “server.js”]`  이 노드 서버를 시작하기 때문이다. 노드 서버는 완료되지 않고 진행 중인 프로세스가 된다.

그래서 컨테이너 또한 실행을 계속 된다.

- **포트 노출**

위 명령 시, EXPOSE 로 포트를 노출했는데도 [localhost:80](http://localhost:80) 으로 접속해도 웹사이트가 표시되지 않는다. 

사실, **EXPOSE 명령은 실제로 도큐먼테이션 목적으로만 추가되었을 뿐, 실제로 컨테이너가 포트를 사용하도록 하게 한 것이 아니다**.

즉, 당연히 EXPOSE 명령을 제거해도 포트를 열 수 있다.

**해당 명령은 선택 사항이지만, 추가하는 것을 권장한다.**

중요한 것은 docker run 컨테이너를 실행할 때 -p 플래그 옵션을 추가해야 하는 것이다.

이를 통해 **도커에게 우리의 로컬의 어떤 포트가 이 내부의 도커 특정 포트에 엑세스 할 수 있는지를 알리는 것.**

```bash
docker run -p 3000:80 해당 이미지 ID
```

**-P : 도커 실행 시, 도커에게 어떤 로컬 포트가 있는지 알려주는 플래그**

1. -p
    
    publish 라는 뜻
    
2. 애플리케이션에 엑세스하려는 로컬 포트를 지정
3. 그 다음 내부 도커 컨테이너 노출 포트를 넣는다.

해당 명령 후, [localhost:3000](http://localhost:3000) 에 접속하면, 애플리케이션이 표시되는 것을 확인할 수 있다. 로컬 포트 3000에 publish 되었기 때문에 작동하게 된다.

### 4. 컨테이너 중지

자동적으로 할당된 컨테이너 이름을 넣어 중지시킨다. 

컨테이너 이름은 docker ps 명령을 통해 확인

```bash
docker stop 컨테이너 이름
```

**** 추가 참고 사항**

 **ID**를 사용하는 모든 **docker 명령**의 경우, **항상 전체 ID를 복사**/기록할 필요가 없다.

고유 식별자를 가질 때 첫번 째 (몇 개) 문자만을 입력하는 것만으로 사용할 수 있다.

`docker run abcdefg`

이 명령 대신

`docker run abc`

이 명령을 실행할 수도 있습니다.

또는 "a"로 시작하는 다른 이미지 ID가 없으면, 다음과 같은 명령을 실행할 수도 있습니다.

`docker run a`

이는 ID를 필요로 하는 모든 Docker 명령어에 적용됩니다.